@page "/intranet/dashboard"
@using CriptoVersus.Web.Services
@using DTOs
@inject CriptoVersus.Web.Services.CriptoVersusApiClient Api
@using Microsoft.AspNetCore.Http.Connections
@using Microsoft.AspNetCore.SignalR.Client
@using System.Text.Json
@inject CriptoVersus.Web.Services.DashboardHubClient HubClient

@inject IJSRuntime JS
<h3 class="mb-3">Dashboard</h3>
@implements IAsyncDisposable

@if (_loading)
{
    <p>Carregando...</p>
}
else if (!string.IsNullOrWhiteSpace(_error))
{
    <div class="alert alert-danger">@_error</div>
}
else if (_snapshot is null)
{
    <div class="alert alert-warning">Sem dados do snapshot.</div>
}
else
{
    <!-- Cards: Matches -->
    <div class="row g-3 mb-3">
        <div class="col-md-4">
            <div class="card text-center">
                <div class="card-body">
                    <div class="text-muted">Pendentes</div>
                    <div class="fs-2 fw-bold">@_snapshot.Matches.Pending</div>
                </div>
            </div>
        </div>

        <div class="col-md-4">
            <div class="card text-center">
                <div class="card-body">
                    <div class="text-muted">Em andamento</div>
                    <div class="fs-2 fw-bold">@_snapshot.Matches.Ongoing</div>
                </div>
            </div>
        </div>

        <div class="col-md-4">
            <div class="card text-center">
                <div class="card-body">
                    <div class="text-muted">Finalizadas (24h)</div>
                    <div class="fs-2 fw-bold">@_snapshot.Matches.CompletedLast24h</div>
                </div>
            </div>
        </div>
        <div class="card">
            <div class="card-body">
                <div class="d-flex justify-content-between align-items-center">
                    <h5 class="card-title mb-0">Worker</h5>
                    <div id="worker-status-badge"></div>
                </div>

                <div class="mt-2" id="worker-health-list"></div>
            </div>
        </div>
        <div class="text-muted small">
            HubState: @HubClient.State | ConnId: @HubClient.ConnectionId | Events: @_eventCount
            | Reloads: @_reloadCount | LastReload: @_lastReloadLocal.ToString("HH:mm:ss")

        </div>
    </div>

    <!-- Worker -->
    <div class="card mb-3">
        <div class="card-header d-flex align-items-center justify-content-between">
            <div>
                <strong>@_snapshot.Worker.ServiceName</strong>
                <span class="badge ms-2 @WorkerBadge">
                    @(_snapshot.Worker.IsAlive ? "ONLINE" : "OFFLINE")
                </span>
            </div>

            <button class="btn btn-sm btn-outline-primary" @onclick="Reload">
                Atualizar
            </button>
        </div>

        <div class="card-body">
            <div class="text-muted">
                Server UTC: @_snapshot.ServerTimeUtc.ToString("yyyy-MM-dd HH:mm:ss")
            </div>
            <div class="text-muted">
                Último heartbeat: @FmtUtc(_snapshot.Worker.LastHeartbeatUtc)
            </div>

            <div class="row mt-2">
                <div class="col-md-4 text-muted">Intervalo: <strong>@_snapshot.Worker.CycleIntervalSeconds</strong>s</div>
                <div class="col-md-4 text-muted">Duração match: <strong>@_snapshot.Worker.MatchDurationMinutes</strong> min</div>
                <div class="col-md-4 text-muted">Alvo próximas: <strong>@_snapshot.Worker.TargetUpcomingMatches</strong></div>
            </div>

            <div class="row mt-2">
                <div class="col-md-6 text-muted">Ciclo início: <strong>@FmtUtc(_snapshot.Worker.LastCycleStartUtc)</strong></div>
                <div class="col-md-6 text-muted">Ciclo fim: <strong>@FmtUtc(_snapshot.Worker.LastCycleEndUtc)</strong></div>
            </div>

            @if (!string.IsNullOrWhiteSpace(_snapshot.Worker.LastError))
            {
                <div class="alert alert-warning mt-3 mb-0">
                    <strong>Último erro:</strong> @_snapshot.Worker.LastError
                    <div class="text-muted mt-1">Quando: @FmtUtc(_snapshot.Worker.LastErrorUtc)</div>
                </div>
            }
        </div>
    </div>

    <div class="row g-3">
        <!-- Próximas partidas -->
        <div class="col-lg-6">
            <div class="card h-100">
                <div class="card-header"><strong>Upcoming</strong></div>
                <div class="table-responsive">
                    <table class="table table-sm table-striped mb-0">
                        <thead>
                            <tr>
                                <th>ID</th>
                                <th>Times</th>
                                <th>Status</th>
                                <th class="text-end">Início</th>
                            </tr>
                        </thead>
                        <tbody>
                            @if (_snapshot.Matches.Upcoming.Count == 0)
                            {
                                <tr><td colspan="4" class="text-muted p-3">Nenhuma partida pendente.</td></tr>
                            }
                            else
                            {
                                @foreach (var m in _snapshot.Matches.Upcoming)
                                {
                                    <tr>
                                        <td>@m.MatchId</td>
                                        <td>@m.TeamA <span class="text-muted">vs</span> @m.TeamB</td>
                                        <td>@m.Status</td>
                                        <td class="text-end">@FmtUtc(m.StartTime)</td>
                                    </tr>
                                }
                            }
                        </tbody>
                    </table>
                </div>
            </div>
        </div>

        <!-- Partidas em andamento -->
        <div class="col-lg-6">
            <div class="card h-100">
                <div class="card-header"><strong>Ongoing</strong></div>
                <div class="table-responsive">
                    <table class="table table-sm table-striped mb-0">
                        <thead>
                            <tr>
                                <th>ID</th>
                                <th>Times</th>
                                <th>Placar</th>
                                <th class="text-end">Tempo</th>
                            </tr>
                        </thead>
                        <tbody>
                            @if (_snapshot.Matches.OngoingList.Count == 0)
                            {
                                <tr><td colspan="4" class="text-muted p-3">Nenhuma partida em andamento.</td></tr>
                            }
                            else
                            {
                                @foreach (var m in _snapshot.Matches.OngoingList)
                                {
                                    <tr>
                                        <td>@m.MatchId</td>
                                        <td>@m.TeamA <span class="text-muted">vs</span> @m.TeamB</td>
                                        <td>
                                            <div>
                                                <strong>@m.ScoreA</strong> x <strong>@m.ScoreB</strong>
                                            </div>

                                            <div class="text-muted small">
                                                @FmtPct(m.PctA) <span class="text-muted">vs</span> @FmtPct(m.PctB)
                                            </div>
                                        </td>

                                        <td class="text-end">
                                            @m.ElapsedMinutes' <span class="text-muted">(-@m.RemainingMinutes')</span>
                                        </td>
                                    </tr>
                                }
                            }
                        </tbody>
                    </table>
                    <div class="text-muted small">
                        HubState: @HubClient.State | ConnId: @HubClient.ConnectionId

                    </div>
                    @if (!string.IsNullOrEmpty(_lastPayload))
                    {
                        <div class="text-muted small">Last: @_lastPayload</div>
                    }

                </div>
            </div>
        </div>

        <!-- Top Gainers -->
        <div class="col-12">
            <div class="card">
                <div class="card-header"><strong>Top Gainers</strong></div>
                <div class="table-responsive">
                    <table class="table table-sm table-striped mb-0">
                        <thead>
                            <tr>
                                <th>#</th>
                                <th>Symbol</th>
                                <th>Name</th>
                                <th class="text-end">%</th>
                                <th class="text-end">Atualizado</th>
                            </tr>
                        </thead>
                        <tbody>
                            @if (_snapshot.TopGainers.Count == 0)
                            {
                                <tr><td colspan="5" class="text-muted p-3">Sem dados.</td></tr>
                            }
                            else
                            {
                                @foreach (var c in _snapshot.TopGainers)
                                {
                                    <tr>
                                        <td>@c.Rank</td>
                                        <td><strong>@c.Symbol</strong></td>
                                        <td>@c.Name</td>
                                        <td class="text-end text-success fw-bold">+@c.PercentageChange.ToString("0.##")%</td>
                                        <td class="text-end">@FmtUtc(c.LastUpdatedUtc)</td>
                                    </tr>
                                }
                            }
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
        <div class="card mt-3">
            <div class="card-header d-flex justify-content-between align-items-center">
                <strong>Debug</strong>

                <div class="btn-group">
                    <button class="btn btn-sm btn-outline-secondary" @onclick="ToggleDebug">
                        @(_debugEnabled ? "Pausar" : "Ativar")
                    </button>
                    <button class="btn btn-sm btn-outline-danger" @onclick="ClearDebug">
                        Limpar
                    </button>
                    <button class="btn btn-sm btn-outline-primary" @onclick="CopyDebug">
                        Copiar
                    </button>
                </div>
            </div>

            <div class="card-body">
                <div class="text-muted small mb-2">
                    RenderMode: @(OperatingSystem.IsBrowser() ? "WASM" : "Server") |
                    HubState: @HubClient.State |
                    ConnId: @HubClient.ConnectionId |
                    Events: @_eventCount |
                    Reloads: @_reloadCount |
                    LastReload: @_lastReloadLocal.ToString("HH:mm:ss")
                </div>

                <pre style="height:260px; overflow:auto; background:#0b0f14; color:#d1d5db; padding:10px; border-radius:6px; font-size:12px; margin:0;">
                    @_debugText
            </pre>
            </div>
        </div>

    </div>
}


@code {
    // JS Worker Badge payload
    private object? _workerJsPayload;
    private bool _workerJsDirty;
    private bool _interactiveReady;

    // UI counters / debug
    private int _eventCount;
    private string? _lastPayload;
    private DateTime _lastReloadLocal = DateTime.Now;
    private int _reloadCount;

    // Data
    private DashboardSnapshotDto? _snapshot;
    private bool _loading = true;
    private string? _error;

    // lifecycle / safety
    private bool _disposed;
    private readonly SemaphoreSlim _reloadLock = new(1, 1);

    private CancellationTokenSource? _debounceCts;
    private CancellationTokenSource? _reloadCts;

    // ===== DEBUG =====
    private bool _debugEnabled = true;
    private const int DebugMaxLines = 500;
    private readonly object _debugLock = new();
    private readonly Queue<string> _debugLines = new();
    private string _debugText = "";

    private void D(string message)
    {
        if (!_debugEnabled) return;

        var line = $"{DateTime.Now:HH:mm:ss.fff} | {message}";

        lock (_debugLock)
        {
            _debugLines.Enqueue(line);
            while (_debugLines.Count > DebugMaxLines)
                _debugLines.Dequeue();

            _debugText = string.Join('\n', _debugLines);
        }

        _ = InvokeAsync(StateHasChanged);
    }

    private void ToggleDebug()
    {
        _debugEnabled = !_debugEnabled;
        // não chama D aqui quando desligar, senão some
        if (_debugEnabled) D("DEBUG => ON");
    }

    private void ClearDebug()
    {
        lock (_debugLock)
        {
            _debugLines.Clear();
            _debugText = "";
        }
        _ = InvokeAsync(StateHasChanged);
    }

    private async Task CopyDebug()
    {
        try
        {
            string text;
            lock (_debugLock) text = _debugText;

            await JS.InvokeVoidAsync("navigator.clipboard.writeText", text);
            D("Debug copiado ✅");
        }
        catch (Exception ex)
        {
            D($"CopyDebug ERRO: {ex.GetType().Name} - {ex.Message}");
        }
    }

    protected override async Task OnInitializedAsync()
    {
        D("OnInitializedAsync INICIO");
        D($"RenderMode: {(OperatingSystem.IsBrowser() ? "WASM" : "Server")} Machine={Environment.MachineName}");
        D($"HubClient instance => {HubClient.InstanceId}");

        HubClient.DashboardChanged += OnDashboardChanged;
        D("Subscribed HubClient.DashboardChanged");

        try
        {
            try
            {
                var ips = await System.Net.Dns.GetHostAddressesAsync("criptoversus-api.duckdns.org");
                D("DNS criptoversus-api.duckdns.org => " + string.Join(", ", ips.Select(i => i.ToString())));
            }
            catch (Exception ex)
            {
                D("DNS resolve ERRO => " + ex.Message);
            }

            D("HubClient.EnsureStartedAsync()...");
            await HubClient.EnsureStartedAsync();
            D($"Hub started OK | State={HubClient.State} ConnId={HubClient.ConnectionId}");
            _error = null;
        }
        catch (Exception ex)
        {
            _error = $"Falha ao conectar no Hub: {ex.Message}";
            D($"ERRO EnsureStartedAsync: {ex}");
            _loading = false; // não trava a tela em loading
            await InvokeAsync(StateHasChanged);
            return;
        }

        D("Primeiro Reload()...");
        await Reload(); // pode falhar/timeout, mas não pode travar a UI
        D("OnInitializedAsync FIM");
    }

    private void OnDashboardChanged(string? payload)
    {
        if (_disposed)
        {
            D("OnDashboardChanged ignorado (disposed=true)");
            return;
        }

        _eventCount++;

        if (string.IsNullOrWhiteSpace(payload))
            _lastPayload = "(notify sem payload)";
        else
            _lastPayload = payload.Length > 200 ? payload[..200] + "..." : payload;

        D($"EVENT dashboard_changed #{_eventCount} | payloadLen={(payload?.Length ?? 0)} | State={HubClient.State} ConnId={HubClient.ConnectionId}");

        // debounce do reload (não bloqueia thread do hub)
        _ = DebouncedReloadAsync(350);
    }

    private Task DebouncedReloadAsync(int ms)
    {
        if (_disposed)
        {
            D("DebouncedReloadAsync ignorado (disposed=true)");
            return Task.CompletedTask;
        }

        try
        {
            _debounceCts?.Cancel();
            _debounceCts?.Dispose();
        }
        catch { /* ignore */ }

        _debounceCts = new CancellationTokenSource();
        var ct = _debounceCts.Token;

        D($"Debounce agendado: {ms}ms");

        return Task.Run(async () =>
        {
            try
            {
                await Task.Delay(ms, ct);
                if (ct.IsCancellationRequested || _disposed)
                {
                    D("Debounce cancelado");
                    return;
                }

                D("Debounce disparou => Reload()");
                await InvokeAsync(Reload);
            }
            catch (OperationCanceledException)
            {
                // esperado
            }
            catch (Exception ex)
            {
                D($"Debounce ERRO: {ex.GetType().Name} - {ex.Message}");
            }
        }, ct);
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            _interactiveReady = true;
            D("OnAfterRender firstRender => interactiveReady=true");
        }

        if (_disposed) return;

        if (_interactiveReady && _workerJsDirty && _workerJsPayload is not null)
        {
            try
            {
                D("OnAfterRender => JS updateWorkerDashboard (dirty)");
                await JS.InvokeVoidAsync("updateWorkerDashboard", _workerJsPayload);
                _workerJsDirty = false;
                D("OnAfterRender => JS OK");
            }
            catch (Exception ex)
            {
                D($"OnAfterRender JS ERRO: {ex.GetType().Name} - {ex.Message}");
            }
        }
    }

    private async Task Reload()
    {
        if (_disposed)
        {
            D("Reload ignorado (disposed=true)");
            return;
        }

        // evita reentrância
        if (!await _reloadLock.WaitAsync(0))
        {
            D("Reload ignorado (lock ocupado)");
            return;
        }

        // cancela qualquer reload anterior pendente (caso tenha travado)
        try
        {
            _reloadCts?.Cancel();
            _reloadCts?.Dispose();
        }
        catch { /* ignore */ }

        _reloadCts = new CancellationTokenSource();
        // timeout explícito pra não ficar eterno em "Carregando..."
        _reloadCts.CancelAfter(TimeSpan.FromSeconds(12));
        var ct = _reloadCts.Token;

        var sw = System.Diagnostics.Stopwatch.StartNew();

        try
        {
            _reloadCount++;
            _lastReloadLocal = DateTime.Now;

            _loading = true;
            _error = null;

            D($"Reload START #{_reloadCount} | HubState={HubClient.State} ConnId={HubClient.ConnectionId}");

            await InvokeAsync(StateHasChanged);

            // CHAMADA API (com timeout)
            D("Api.GetDashboardSnapshotAsync()...");
            var task = Api.GetDashboardSnapshotAsync();

            // não dá pra passar ct se o método não aceita, então fazemos WaitAsync
            _snapshot = await task.WaitAsync(ct);

            D($"Snapshot OK | serverUtc={_snapshot.ServerTimeUtc:O} | workerAlive={_snapshot.Worker?.IsAlive}");

            if (_snapshot?.Worker is not null)
            {
                var secondsSinceHeartbeat =
                    (int)(DateTime.UtcNow - _snapshot.Worker.LastHeartbeatUtc).TotalSeconds;

                _workerJsPayload = new
                {
                    tx_health_json = "(debug)",
                    in_degraded = !_snapshot.Worker.IsAlive,
                    secondsSinceHeartbeat,
                    cycleIntervalSeconds = _snapshot.Worker.CycleIntervalSeconds
                };

                _workerJsDirty = true;

                D($"Worker payload ready | secondsSinceHeartbeat={secondsSinceHeartbeat} dirty=true interactiveReady={_interactiveReady}");

                if (_interactiveReady)
                {
                    try
                    {
                        D("JS updateWorkerDashboard()...");
                        await JS.InvokeVoidAsync("updateWorkerDashboard", _workerJsPayload);
                        _workerJsDirty = false;
                        D("JS OK (updateWorkerDashboard)");
                    }
                    catch (Exception ex)
                    {
                        D($"JS ERRO: {ex.GetType().Name} - {ex.Message}");
                    }
                }
            }
        }
        catch (OperationCanceledException)
        {
            _error = "Timeout ao buscar snapshot (12s).";
            D("Reload TIMEOUT/Cancel (12s) ✅");
        }
        catch (Exception ex)
        {
            _error = ex.ToString();
            D($"Reload ERRO: {ex}");
        }
        finally
        {
            sw.Stop();
            _loading = false;

            try { _reloadLock.Release(); } catch { }

            D($"Reload END (ms={sw.ElapsedMilliseconds})");
            await InvokeAsync(StateHasChanged);
        }
    }

    public async ValueTask DisposeAsync()
    {
        _disposed = true;

        HubClient.DashboardChanged -= OnDashboardChanged;

        try { _debounceCts?.Cancel(); } catch { }
        _debounceCts?.Dispose();
        _debounceCts = null;

        try { _reloadCts?.Cancel(); } catch { }
        _reloadCts?.Dispose();
        _reloadCts = null;

        _reloadLock.Dispose();

        await Task.CompletedTask;
    }

    private string WorkerBadge => _snapshot?.Worker.IsAlive == true ? "bg-success" : "bg-danger";

    private static string FmtPct(decimal? v)
    {
        if (v is null) return "-";
        var sign = v.Value >= 0 ? "+" : "";
        return $"{sign}{v.Value:0.##}%";
    }

    private static string FmtUtc(DateTime? dt)
        => dt is null ? "-" : dt.Value.ToLocalTime().ToString("dd/MM/yyyy HH:mm:ss");

    private static string FmtUtc(DateTime dt)
        => dt.ToLocalTime().ToString("dd/MM/yyyy HH:mm:ss");
}






