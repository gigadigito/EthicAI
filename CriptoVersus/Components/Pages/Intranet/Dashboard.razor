@rendermode InteractiveServer
@page "/intranet/dashboard"
@using CriptoVersus.Web.Services
@using DTOs
@inject CriptoVersus.Web.Services.CriptoVersusApiClient Api
@using Microsoft.AspNetCore.Http.Connections
@using Microsoft.AspNetCore.SignalR.Client
@using System.Text.Json
@inject IJSRuntime JS
@inject CriptoVersus.Web.Services.DashboardHubClient HubClient

@inject IJSRuntime JS
<h3 class="mb-3">Dashboard</h3>

<div class="small text-muted">
    PROVA: renderStamp=@_renderStamp | renderCount=@_renderCount | now=@DateTime.Now.ToString("HH:mm:ss.fff")
</div>
<button class="btn btn-sm btn-outline-secondary mb-2" @onclick="ForceRender">
    ForceRender
</button>
<ErrorBoundary @ref="_eb">
    <ChildContent>
        @* seu conteúdo atual *@
    </ChildContent>
    <ErrorContent Context="ex">
        <div class="alert alert-danger">
            <strong>Erro no render:</strong> @ex.GetType().Name - @ex.Message
            <div class="small text-muted mt-2">@ex.ToString()</div>
        </div>
    </ErrorContent>
</ErrorBoundary>

@implements IAsyncDisposable

@if (_loading)
{
    <p>Carregando...</p>
}
else if (!string.IsNullOrWhiteSpace(_error))
{
    <div class="alert alert-danger">@_error</div>
}
else if (_snapshot is null)
{
    <div class="alert alert-warning">Sem dados do snapshot.</div>
}
else
{
    <DashboardView 
                   Snapshot="_snapshot"
                   EventCount="_eventCount"
                   ReloadCount="_reloadCount"
                   LastReloadLocal="_lastReloadLocal"
                   LastPayload="_lastPayload"
                   DebugText="_debugText"
                   DebugEnabled="_debugEnabled"
                   ReloadRequested="Reload" />
}



@code {
   
    // JS Worker Badge payload
    private object? _workerJsPayload;
    private bool _workerJsDirty;
    private bool _interactiveReady;

    // UI counters / debug
    private int _eventCount;
    private string? _lastPayload;
    private DateTime _lastReloadLocal = DateTime.Now;
    private int _reloadCount;
    private ErrorBoundary? _eb;

    // Data
    private DashboardSnapshotDto? _snapshot;
    private bool _loading = true;
    private string? _error;

    // lifecycle / safety
    private bool _disposed;
    private readonly SemaphoreSlim _reloadLock = new(1, 1);

    private CancellationTokenSource? _debounceCts;
    private CancellationTokenSource? _reloadCts;

    // ===== DEBUG =====
    private bool _debugEnabled = true;
    private const int DebugMaxLines = 500;
    private readonly object _debugLock = new();
    private readonly Queue<string> _debugLines = new();
    private string _debugText = "";

    private volatile int _reloadPending = 0; // 0/1

    private DotNetObjectReference<Dashboard>? _objRef;
    private string? _connId;
    private int _events;
    private long _renderCount;
    private string _renderStamp = Guid.NewGuid().ToString("N");

    private Task ForceRender()
    {
        _renderStamp = Guid.NewGuid().ToString("N");
        return InvokeAsync(StateHasChanged);
    }



    private void D(string message)
    {
        if (!_debugEnabled) return;

        var line = $"{DateTime.Now:HH:mm:ss.fff} | {message}";

        lock (_debugLock)
        {
            _debugLines.Enqueue(line);
            while (_debugLines.Count > DebugMaxLines)
                _debugLines.Dequeue();

            _debugText = string.Join('\n', _debugLines);
        }

        // NÃO chamar StateHasChanged aqui
    }


    private void ToggleDebug()
    {
        _debugEnabled = !_debugEnabled;
        // não chama D aqui quando desligar, senão some
        if (_debugEnabled) D("DEBUG => ON");
    }

    private void ClearDebug()
    {
        lock (_debugLock)
        {
            _debugLines.Clear();
            _debugText = "";
        }
        _ = InvokeAsync(StateHasChanged);
    }

    private async Task CopyDebug()
    {
        try
        {
            string text;
            lock (_debugLock) text = _debugText;

            await JS.InvokeVoidAsync("navigator.clipboard.writeText", text);
            D("Debug copiado ✅");
        }
        catch (Exception ex)
        {
            D($"CopyDebug ERRO: {ex.GetType().Name} - {ex.Message}");
        }
    }
    protected override void OnInitialized()
    {
        D("OnInitialized (sync) => render liberado");

        HubClient.DashboardChanged += OnDashboardChanged;

        // dispara a inicialização sem bloquear o primeiro render
        _ = InitializeDashboardAsync();
    }
    private async Task SafeEnsureHubStartedAsync(TimeSpan timeout)
    {
        try
        {
            D("Hub => EnsureStartedAsync (timeout)...");
            await HubClient.EnsureStartedAsync().WaitAsync(timeout);
            D($"Hub => OK State={HubClient.State} ConnId={HubClient.ConnectionId}");
        }
        catch (Exception ex)
        {
            // NÃO trava a tela por causa do hub
            D($"⚠️ Hub => falhou/timeout: {ex.GetType().Name} - {ex.Message}");
        }
    }

    private async Task InitializeDashboardAsync()
    {
        _loading = true;
        _error = null;

        try
        {
            await InvokeAsync(StateHasChanged);

            // 1) DISPARA o start do hub, mas NÃO BLOQUEIA a tela nele
            var hubStartTask = SafeEnsureHubStartedAsync(TimeSpan.FromSeconds(5));

            // 2) CARREGA snapshot já (isso deve resolver o "carregando infinito")
            D("Init => carregando snapshot (sem esperar hub)...");
            _snapshot = await Api.GetDashboardSnapshotAsync().WaitAsync(TimeSpan.FromSeconds(12));
            D("Init => snapshot OK");

            // força reconstruir a view
          
            await InvokeAsync(StateHasChanged);

            // 3) Agora, se o hub terminar depois, beleza. Se falhar, a UI continua.
            _ = hubStartTask; // fire and forget (já tem log/erro interno)
        }
        catch (Exception ex)
        {
            _error = $"Falha ao carregar snapshot: {ex.GetType().Name} - {ex.Message}";
            D($"❌ Init snapshot ERRO: {ex}");
        }
        finally
        {
            _loading = false;
            await InvokeAsync(StateHasChanged);
            D("Init => FIM (loading=false)");
        }
    }



   


    private void OnDashboardChanged(string? payload)
    {
        if (_disposed)
        {
            D("OnDashboardChanged ignorado (disposed=true)");
            return;
        }

        _eventCount++;

        if (string.IsNullOrWhiteSpace(payload))
            _lastPayload = "(notify sem payload)";
        else
            _lastPayload = payload.Length > 200 ? payload[..200] + "..." : payload;

        D($"EVENT dashboard_changed #{_eventCount} | payloadLen={(payload?.Length ?? 0)} | State={HubClient.State} ConnId={HubClient.ConnectionId}");

        // debounce do reload (não bloqueia thread do hub)
        _ = DebouncedReloadAsync(350);
    }

    private Task DebouncedReloadAsync(int ms)
    {
        if (_disposed)
        {
            D("DebouncedReloadAsync ignorado (disposed=true)");
            return Task.CompletedTask;
        }

        try
        {
            _debounceCts?.Cancel();
            _debounceCts?.Dispose();
        }
        catch { /* ignore */ }

        _debounceCts = new CancellationTokenSource();
        var ct = _debounceCts.Token;

        D($"Debounce agendado: {ms}ms");

        return Task.Run(async () =>
        {
            try
            {
                await Task.Delay(ms, ct);
                if (ct.IsCancellationRequested || _disposed)
                {
                    D("Debounce cancelado");
                    return;
                }

                D("Debounce disparou => Reload()");
                await InvokeAsync(Reload);
            }
            catch (OperationCanceledException)
            {
                // esperado
            }
            catch (Exception ex)
            {
                D($"Debounce ERRO: {ex.GetType().Name} - {ex.Message}");
            }
        }, ct);
    }

    [JSInvokable]
    public Task OnDashboardChangedFromJs(string? json)
    {
        _events++;
        // aqui você faz: atualizar estado e chamar Reload()
        // json pode ser null ou {"table":"match",...}
        // Ex:
        // _lastPayload = json ?? "(null)";
        // return Reload();

        Console.WriteLine($"JS dashboard_changed #{_events} payload={json}");
        return InvokeAsync(StateHasChanged);
    }

    public async ValueTask DisposeAsync()
    {
        try
        {
            await JS.InvokeVoidAsync("DashboardHubWs.stop");
        }
        catch { /* ignore */ }

        _objRef?.Dispose();
    }
     
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        _renderCount++;

        if (firstRender)
        {
            // só loga 1 vez, sem StateHasChanged
            D($"🔥 OnAfterRenderAsync firstRender={firstRender}");
        }
   
        try
        {
            // log no console do browser (não bloqueia)
            await JS.InvokeVoidAsync("console.warn", $"[Blazor] OnAfterRenderAsync firstRender={firstRender}");

            if (!firstRender) return;

            D("🔥 OnAfterRender firstRender => criando objRef e chamando JS...");

            // _objRef?.Dispose();
            // _objRef = DotNetObjectReference.Create(this);

            // await JS.InvokeVoidAsync("DashboardHubWs.setDotnetRef", _objRef);

            // var url = "https://criptoversus-api.duckdns.org/hubs/dashboard";
            // _connId = await JS.InvokeAsync<string>("DashboardHubWs.start", url);

            D($"🔥 DashboardHubWs.start OK connId={_connId}");
        }
        catch (Exception ex)
        {
            // ISSO aqui é o que vai revelar se é prerender/interop bloqueado
            D($"❌ OnAfterRenderAsync ERRO: {ex.GetType().Name} - {ex.Message}");
            try { await JS.InvokeVoidAsync("console.error", "[Blazor] OnAfterRenderAsync ERRO:", ex.ToString()); } catch { }
        }
     
    }


    // protected override async Task OnAfterRenderAsync(bool firstRender)
    // {
    //     if (firstRender)
    //     {
    //         _interactiveReady = true;
    //         D("OnAfterRender firstRender => interactiveReady=true");
    //     }

    //     if (_disposed) return;

    //     if (_interactiveReady && _workerJsDirty && _workerJsPayload is not null)
    //     {
    //         try
    //         {
    //             D("OnAfterRender => JS updateWorkerDashboard (dirty)");
    //             await JS.InvokeVoidAsync("updateWorkerDashboard", _workerJsPayload);
    //             _workerJsDirty = false;
    //             D("OnAfterRender => JS OK");
    //         }
    //         catch (Exception ex)
    //         {
    //             D($"OnAfterRender JS ERRO: {ex.GetType().Name} - {ex.Message}");
    //         }
    //     }
    // }

    private async Task Reload()
    {
        if (_disposed)
        {
            D("Reload ignorado (disposed=true)");
            return;
        }

        // evita reentrância
        if (!await _reloadLock.WaitAsync(0))
        {
            // NÃO IGNORA: marca pendente
            Interlocked.Exchange(ref _reloadPending, 1);
            D("Reload busy => marcado pendente");
            return;
        }
        // cancela qualquer reload anterior pendente (caso tenha travado)
        try
        {
            _reloadCts?.Cancel();
            _reloadCts?.Dispose();
        }
        catch { /* ignore */ }

        _reloadCts = new CancellationTokenSource();
        // timeout explícito pra não ficar eterno em "Carregando..."
        _reloadCts.CancelAfter(TimeSpan.FromSeconds(12));
        var ct = _reloadCts.Token;

        var sw = System.Diagnostics.Stopwatch.StartNew();

        try
        {
            do
            {
                // consome o "pendente" ANTES de rodar
                Interlocked.Exchange(ref _reloadPending, 0);

                _reloadCount++;
                _lastReloadLocal = DateTime.Now;
                _eb?.Recover();
                _loading = false;
                _error = null;

                D($"Reload START #{_reloadCount} | HubState={HubClient.State} ConnId={HubClient.ConnectionId}");
                await InvokeAsync(StateHasChanged);

                D("Api.GetDashboardSnapshotAsync()...");
                var task = Api.GetDashboardSnapshotAsync();
                _snapshot = await task.WaitAsync(ct);

            

               
                await InvokeAsync(StateHasChanged);
               

                
                await InvokeAsync(StateHasChanged);

                D($"Snapshot OK | serverUtc={_snapshot.ServerTimeUtc:O} | workerAlive={_snapshot.Worker?.IsAlive}");

                
                D("Reload UI apply");
                await InvokeAsync(StateHasChanged);

                // se enquanto você rodava alguém pediu reload, o loop roda mais 1
                if (Volatile.Read(ref _reloadPending) == 1)
                    D("Reload pendente detectado => vai rodar mais 1");

            } while (Volatile.Read(ref _reloadPending) == 1 && !_disposed);
        }
        finally
        {
            _loading = false;
            try { _reloadLock.Release(); } catch { }
            D("Reload END (lock released)");
            await InvokeAsync(StateHasChanged);
        }

    }

    // public async ValueTask DisposeAsync()
    // {
    //     _disposed = true;

    //     HubClient.DashboardChanged -= OnDashboardChanged;

    //     try { _debounceCts?.Cancel(); } catch { }
    //     _debounceCts?.Dispose();
    //     _debounceCts = null;

    //     try { _reloadCts?.Cancel(); } catch { }
    //     _reloadCts?.Dispose();
    //     _reloadCts = null;

    //     _reloadLock.Dispose();

    //     await Task.CompletedTask;
    // }

    private string WorkerBadge => _snapshot?.Worker.IsAlive == true ? "bg-success" : "bg-danger";

    private static string FmtPct(decimal? v)
    {
        if (v is null) return "-";
        var sign = v.Value >= 0 ? "+" : "";
        return $"{sign}{v.Value:0.##}%";
    }

    private static string FmtUtc(DateTime? dt)
        => dt is null ? "-" : dt.Value.ToLocalTime().ToString("dd/MM/yyyy HH:mm:ss");

    private static string FmtUtc(DateTime dt)
        => dt.ToLocalTime().ToString("dd/MM/yyyy HH:mm:ss");
}






